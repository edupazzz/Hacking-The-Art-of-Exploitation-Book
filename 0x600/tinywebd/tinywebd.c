#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <signal.h>
#include <string.h>
#include "hacking.h"
#include "hacking-network.h"

#define PORT 80 // The port users will be connecting to
#define WEBROOT "./webroot" // The webserver's root directory
#define LOGFILE "/var/log/tinywebd.log" // Log file name

int logfd, sockfd; // Global log and socket file descriptors
void handle_connection(int, struct sockaddr_in *, int);
int get_file_size(int); // Returns the file size of open file descriptor
void timestamp(int); // Writes a timestamp to the open file descriptor

// This function is called when the process is kelled:
void handle_shutdown(int signal)
{
  timestamp(logfd);
  write(logfd, "Shutting down.\n", 16);
  close(logfd);
  close(sockfd);
  exit(0);
}

int int main(void)
{
    int new_sockfd, yes=1;
    struct sockaddr_in host_addr, client_add; // My address information
    socklen_t sin_size;

    logfd = open(LOGFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
    if(logfd = -1)
      fatal("opening log file");

    if((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
      fatal("in socket");

    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
      fatal("setting socket option SO_REUSEADDR");

    printf("Starting tiny web deamon.\n");
    if(deamon(1,0) == -1) // Fork to a background deamon process
      fatal("forking to deamon process");

    signal(SIGTERM, handle_shutdown); // Call handle_shutdown when killed
    signal(SIGINT, handle_shutdown); // Call handle_shutdown when interrupted

    timestamp(logfd);

    write(logfd, "Starting up.\n", 15);
    host_addr.sin_family = AF_INET; // Host byte order
    host_addr.sin_port = htons(PORT); // Short, network byte order
    host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.
    memset(&(host_addr.sin_zero), '\0', 8); // Zero the rest of the struct.

    if(bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)
      fatal("binding to socket");

    if(listen(sockfd, 20) == -1)
      fatal("listening on socket");

    while(1) // Accept loop
    {
      sin_size = sizeof(struct sockaddr_in);
      new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, sin_size);
      if(new_sockfd == -1)
        fatal("accepting connection");

      handle_connection(new_sockfd, &client_add, logfd)
    }
    return 0;
}
